Prologでλ→の型検査のプログラムを書いてみた「だけ」の話

2016_夏

@suharahiromichi


1. 概要

Prologでλ→の型検査のプログラムを書いてみた。
それ「だけ」で、型検査と型付け のどちらにも使える。

キーワード：

Prolog, λ式, λ→, STLC, TAPL
型システム、型検査、型推論、型付け


2. Prolog とは

(1) 第一階述語論理（注）の定理の証明をプログラムの実行とみなす言語
    （注：ホーン節とよばれるサブセット）
    定理証明系と見たとき、健全だが完全ではない。

(2) ユニフィケーションとバックトラックに基づく言語

(3) 単に Prolog といったとき、ISO標準 Prolog (DEC-10 Prolog または
    Edinburgh Prolog の後継言語・処理系) を指す。

    処理系の例：
    SWI-Prolog (アムステルダム大学, アムステルダム自由大学)
    GNU Prolog (Daniel Diaz (パリ第1大学))
    AZ-Prolog  (ソフネック株式会社、個人と教育・研究機関は無償利用可能)



2. 用語と表記について

   定数 ：      小文字から始まる。または、数値（ここでは整数のみ）。
   変数 ：      大文字から始まる。
   「_」から始まる語は、ワイルドカード変数（同名でも別なもの）
   項   ：       f(x, Y, z)

   述語：       だいたい常識的な意味？
                p(X, Y) のpは、定数であること。第一階述語論理なので。
                また、口語では「述語p」と言うこともある。

   関数：       スコーレム関数。。。。
                f(X, Y) のfは、データ構造のコンストラクタと考えてよい。
                fは定数であること。
   
   確定節：      P :- Q, R.
                (P :- true. は P. と書く)
   ゴール節：    ?- P.

   リスト：      [X, y, z]
                 [x y | Z]      (OCaml x :: y :: Z)
                 []

   X = Y :       変数XとYがユニフィケーションする。(「X = Y」は組込み述語）。

   true         常に成功する述語。
   fail         常に失敗する述語。falseと同じだがfailのほうをつかう？
   
   予約語はない。trueやfailは組込み述語。


3. 連想リストの探索の例

連想リストのキー A に対する値 T を返す。
連想リストの要素は、タプル、(KEY : VAL) とする。


3.1 OCaml では、

let rec assoc a l =
  match l with
    | []           -> error    (* エラー *)
    | (a : t) :: _ -> t
    | _       :: l -> assoc a l


3.2 Prolog では


(あ）素朴な書き換え

assoc(A, [(A : T) | _], T).
assoc(A, [_       | L], T) :- assoc(A, L, T).

(0) 値を返すための、3引数になる。
(1) falseの節
    条件が満たされなければ失敗（fail すなわな false とみなす）
(2) ユニフィケーションによる双方向性がある。
    Aが変数なら、変数に一致した結果をセットして返す。
(3) バックトラックにより全解を求める。
    (2)のとき、一致するものが複数ならをそのすべてを返す。
        

（い) これは、2引数にできる。
      ひとつの引数の中でもユニフィケーションするから。…

assoc2((A : T), [(A : T) | _]).
assoc2((A : T), [_       | L]) :- assoc2((A : T), L).


（う）(A : T) はまとめられる。

assoc2(X, [X | _]).
assoc2(X, [_ | L]) :- assoc2(X, L).


（え）実は組込み述語がある。Xがリストの要素に含まれるか。

member(X, [X | _]).
member(X, [_ | L]) :- member(X, L).


3.3 実行例

?- member((f : X), [(g : 1), (f : 1), (h : 1), (g : 2), (f : 2), (h : 2)]).
↓
?- member(f(X), [(f : 1), (h : 1), (g : 2), (f : 2), (h : 2)]).
↓
true.                                                   最初の解 X = 1
全解を求めるためにバックトラックする。
                    ↓
    ?- member((f : X), [(h : 1), (g : 2), (f : 2), (h : 2)]).                
                    ↓
    ?- member((f : X), [(g : 2), (f : 2), (h : 2)]).
                    ↓
    ?- member((f : X), [(f : 2), (h : 2)]).
                    ↓
    true.                                               二番目の解 X = 2
    全解を求めるためにバックトラックする。
                              ↓
    ?- member((f : X), [(h : 2)]).
                              ↓
                              ↓
    ?- member((f : X), []).
                              ↓
    fail.                                               これ以上の解は無いので失敗する。




4. Algorithm = Logic + Control
   
   強力（無節操）なユニフィケーションとバックトラックを「制御」する。
   
   双方向のユニフィケーション
   - occurs check
   

   無制限なバックトラック
   - cut operater     「証明木の枝を刈る」
   


5. 双方向のユニフィケーション

   述語呼び出し時の引数の結合、および、 演算子「=」の両辺の間で、双方
   向にユニフィケーションがおきる。

   引数に「入力」と「出力」の区別がない。「=」に（代入）左辺と右辺の区別がない。
   さらに、変数と定数を混ぜ合わせててもよい。
   
   [1, Y, 3] = [X, 2, Z] の結果は X は 1、Y は 2、 Z は 3 になる。

   f(X) = X は、f(f(f(f(f(f....))))) になる。

   
   「X = Y」の代わりに unify_with_occurs_check(X, Y) を使う

   または、set_prolog_flag(occurs_check, true). を実行しておく。


6. バックトラックの制限

member2(X, L) :-
        member(X, L), !.        /* member の定義は同じ。 */

?- member2(f(X), [g(1), f(1), h(1), g(2), f(2), h(2)]).
↓
?- member(f(X), [g(1), f(1), h(1), g(2), f(2), h(2)]), !.
↓
?- member(f(X), [f(1), h(1), g(2), f(2), h(2)]), !.
↓
!
true.                                                   最初の解 X = 1
全解を求めるためにバックトラックする。
                    ↓
                   fail.


補足説明：
member2の定義は以下と同じ。

（あ）member2が決定性述語であることを明確にする。
        大きなプログラムでは奨励される（かも）。

member2(X, [X | _]) :- !.
member2(X, [_ | L]) :- member2(X, L).


（い）if-then-else 制御構造を使う。実は（あ）の構文糖。

member2(X, [Y | L]) :-
  X = Y -> true ; member2(X, L).
  


7. TAPLの getTypeFromContext


getTypeFromContext x ctx

コンテキスト ctx において、変数xの型を返す（日本語版p.87）。
TAPLでは、de Bruijn Index を使うが、ここでは一般的なλ式を使う。

let rec getTypeFromContext x ctx
  match ctx with
    | []             -> error   (* エラー *)
    | (x : t) :: _   -> t
    | _       :: ctx -> getTypeFromContext x ctx

一般的なλ式の場合、コンテキストは連想リストになる。
変数がxのとき、連想リストから (x : t) を探して、Tを返す。



8. Prolog のgetTypeFromContext
これをmemberの双方向性を使って書く。

getTypeFromContext((X : T), CTX) :-     /* だめだめ */
    member((X : T), CTX).               /* だめだめ */


問題(1) 変数の重なり

内側のコンテキストと外側のコンテキストに同名の変数があっても、それが偶
然であるから、内側のコンテキストだけを取り出さないといけない。
つまり、memberの非決定性は不要である。

対策：カット！


問題(2) 型の「ループ」

λx.x x の本体 (x x) の全体の型をT1、二番目のxの型をTxとする。
すると、一番目のxの型はTx->T1になるが、これもTxであるはずだから、Tx = Tx->T1 になる。
つまり、xの型は Tx かつ Tx->T1 になってしまい、これは型としておかしい。

対策：Occures Check を入れる。


getTypeFromContext((X : T1), CTX) :-
    member((X : T2), CTX), !,
    unify_with_occurs_check(T1, T2).


9. TAPLの typeof を移植する。



10. 実行例


11. de Bruijn Index を使う場合

de Bruijn Index を使う場合、コンテキストは配列になる。
（de Bruijn Index として0から使う場合、0から始まる配列になる。)

nth0(N, L, T) は、リストを0始まりの配列とみなして、(0から数えて)N番めの要素を返す。
memberをnth0に置き換える。nth0は決定的なので、カットは不要になる。

getTypeFromContext((X : T1), CTX) :-
    nth0(X, CTX, T2),
    unify_with_occurs_check(T1, T2).



12. Sytem F への拡張



13. まとめ

Prologでλ→の型検査のプログラムを書いてみた。
それ「だけ」で、型検査と型付け のどちらにも使える。

以上
